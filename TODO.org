* TODO forall and exists clauses for variable functions of variables
** Example
[ (X, ..)
  (Y,              Exists [X] $ ...)
  (W, Exists [Y] $ ForAll [X(Y)] ...)
  (V, Exists [Y] $ Exists [X(Y)] ...) ]
** Analysis
Y, W and V all quantify across some set of Xs.
Y quantifies existentially across all the Xs.
  It draws those X values from the result of the X query.
W and V quantify across only those Xs associated with the Y in question.
  They both draw X values the results of the Y query, not the X query.
* the "Hera's grandchild and not Zeus's child" query
** query
X <- every child of Zeus
Y <- every child of Hera
Z <- every child of some Y s.t. for all X, X /= Y
** representation
[ (X, QFind <child of Zeus> )
, (Y, QFind <child of Hera> )
, (Z, QForSome [Y] $ QAnd [ QFind <child of Y>
                          , QForAll [X] $ QCond <Y /= X> ] ) ]
** algorithm
For X: do it.
For Y: do it.
For Z: For each possible binding of Y
  for each C among the children of Y
    for each possible binding of X -- At this point the subst'n uses 2 vars.
      test whether X == Y
      if at any point they are equal, abort
    if that innermost loop never aborted
      add* the following association the Z-result:
        (Var "C" = C) -> (Var "Y" = Y)
        * where by "add" I mean use insertWith to add (Var "Y" = Y) to the
         set of possible bindings that make (Var "C" = C) valid..
* a variable (here, X) can be quantified existentially in one place and universally in another
** query
X <- in children(Zeus)
Y <- in children(Hera)
Z <- for some Y, in children(Y)
     & for all X, not equal to X
W <- for some X, in children(X)
     & for all Z, for all Y(Z), not( has_battled( W, Y(Z) ) )
       Need two forall statements here because Y(Z) is meaningless until Z has a binding.
* TODO disjunctions can make a variable's dependencies on other variables depend on the first one's value
** The problem
X <- children of Thor
Y <- children of Malox
Z <- for some Y, Z knows Y
     or for some X, Z knows X
These are every person who knows a child of Thor or a child of Malox. For some values of Z, Y is defined and X not; for other values of Z, X is defined and Y not.
** It can be solved by rewriting the query
X <- children of Thor
Y <- children of Malox
W <- X or Y
Z <- for some W, Z knows W

** The first (problematic) query should be valid
** But in that case certian result requests are meaningless
The user cannot ask for X(Z) or Y(Z).
** Only common dependencies survive disjunction
When taking the disjunction of two queries, retain any variable dependencies that are defined for every member of the disjunction. So, for instance, if one query is dependent on nothing, then no variable dependencies will be recorded.

* temporary user burdens: query order, dependency validity
Eventually the code should be able to determine which queries depend on which others, and whether a sequential solution exists.
