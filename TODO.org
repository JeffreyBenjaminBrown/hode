* PIFALLs
** PITFALL: Each mapping in a CondElts can be represented many ways, depending on whether they key is included.
The current idiom is to leave the key out. But -- you could describe a CondElts this way:
 x=1 if (a=1    ) or (b=1    )
or equivalently, this way:
 x=1 if (a=1,x=1) or (b=1,x=1)
or this way:
 x=1 if (a=1    ) or (b=1,x=1)
etc.
** PITFALL: The empty set is nonsense in a CondElts
type CondElts = Map Elt (Set Subst)
  -- ^ Uses `Set` because multiple `Subst`s might obtain the same `Elt`.
  -- PITFALL: If Elt is possible without any other bindings, then
  -- the `Set` should include `M.empty`. If the `Set` is `S.empty`,
  -- it is as if that `Elt` is not in the `Map`.
** PITFALL ? a VarTest's deps record Vars in the Subst, not the Possible, right?
 That's necessarily how varTestCompare is written (unless it has no deps),
 and that's how varTestIO' is currently written, but it could go either way.
 (varTestIO could be interpreting as doing both.)
* TODO re. Search
** TODO ? Is the string arg to findFrom needed?
** TODO ? define not just sets, but set-valued functions of Substs
Example (for a singleton Subst): define "ancestors-via-is" as a function of a Var v: It finds everything v' such that (v is v') or (v' is v), then every v'' such that (v'' is v') or (v' is v'') for one of the v's, etc. This allows the set-valued function of v to be referred to by subsequent Queries, without having to recompute the set.
** TODO ? searches that take both Subst and Possible arguments
* TODO re. Rslt
** TODO : recursive "is", using "is a kind of"
If "brilliant #(is a kind of) bright", I should be able to search for everything that #is bright, and have brilliant things returned, without needing them to be labeled bright.
** TODO explore : can I run these queries
*** a <- everything that needs something
as <- everything that "_ needs _" is in, in the template role
bs <- everything that, for some a in as, is in a, as the first member
*** a <- everything that needs something and isn't dog
as <- everything that "_ needs _" is in, in the template role
bs <- everything that
  (1) for some a in as, is in a, as the first member
  (2) is not dog
*** a <- everything that needs something and is needed by something
as <- everything that "_ needs _" is in, in the template role
bs <- everything such that
      (1) for some a in as, it is the first member
      (2) for some a in as, it is the second member
*** a <- eveyrthing that needs some x and helps some y, such that x != y
** features
*** DSL for exprs
*** DSL for queries
*** GUI
** add Expr wrapper for display
ExprImg = ExprImg Expr | Bracket
*** Show addresses as numbers?
  eShow r (ExprAddr a) = Right $ bracket_angle_small_left
                          : show a ++ [bracket_angle_small_right]
** (#fast) isIn ought to return two maps, not a set
 a map from Role to Set Addr
   because the item in question often holds the same Role in multiple Exprs
 a map from Addr to Set Role
   because the item in question could (although this will be rare) hold
   multiple Roles within the same Expr
* ? To avoid redundant tree-climbing
Recursive calls to a function that evaluates something at an ExprImg by first evaluating it along each of its branches could be expensive. It could be avoided by making the ImgExpr abstract, a functor over some parameter a that is paired with each constructor.
* Add a check, and amend docs: All the Vars in a Program must be distinct.
Relax ? I can't think of a reason that the name of a drawn variable has to be distinct from the name of the set it is drawn from.
* ? how to make variable collision avoidance easier?
Consider QAnd [ Find child of some x, Test equal to no x].
That's an existential find followed by a universal test over the same variable. The find binds x, then the Test deletes that binding.
The solution is to change the varName in the Test. This puts, however,
an annoying burden on the user.
* ? safety, speed
** use lists in some places for fusion, short-circuiting, instead of maps, sets
Example: mapping over a map, and then looking for lefts, is slower than turning the map into a list, mapping over the list, and short-circuiting at the first Left.
hLookup (the Hash language find routine) called on the HMap constructor, for instance, does this.
** maybe VarTest ought to be SubstTest
** clarity: _conditions should just be Query, not [Query]
Currently the list is equivalent to an And.
For this I've got to be able to make the empty VarTest, which always returns True.
** speed when asking for multiple variables that determined a given one
 For varPossibilities, just use the unconditional found values.
 For the input-output criteria, just use VarTest.
*** once that's complete, ditch some unused functions in Subst.hs
*** for more speed, while still pretty simple
(*much* simpler than the input-output-matching varPossibilities strategy I was working on)
Track inputs and outputs. Then, to cut down on the number of varPossibilities tried, allow the user to ask for one flavor (variable name) of input or output to one found Query result. Any additional input-output-matching criteria are imposed via VarTest.
How inputs are tracked (already true):
  Look up a result Var in the Possible.
  In the resulting CondElts, look up a value for the same Var.
  This produces all the possible Substs that could lead there.
How outputs could be tracked:
  Look up an input Var in the Possible.
  In the resulting [?], Look up a value of that Var.
  In the resulting [?], look up the output Var.
  This produces all the possible values that input value could cause in the output.
** speed|space optimization
*** skip recording unneeded dependent bindings
You can tell from reading a Program's [ (VarFunc, Query) ] argument which elements of the Substs will never be referred to; those would not have to be recorded.
** todo ? safety : check that every Set in a CondElts is nonempty
** ? test mixed queries more
* DONE ? overly cautious
** fancy alternatives to Either
 Matt Parsons's magic generic-lens strategy:
   https://www.parsonsmatt.org/2018/11/03/trouble_with_typed_errors.html
 more:
   https://www.fpcomplete.com/blog/defining-exceptions-in-haskell
** add check ? the Query in a _conditions field should be varTestlike
Seems like it should get caught when something tries to run runVarTestlike on it.
* DONE ? obvious
** forall and exists clauses for variable functions of variables
*** Example
 [ (X, ..)
   (Y,              Exists [X] $ ...)
   (W, Exists [Y] $ ForAll [X(Y)] ...)
   (V, Exists [Y] $ Exists [X(Y)] ...) ]
*** Analysis
 Y, W and V all quantify across some set of Xs.
 Y quantifies existentially across all the Xs.
   It draws those X values from the result of the X query.
 W and V quantify across only those Xs associated with the Y in question.
   They both draw X values the results of the Y query, not the X query.
** the "Hera's grandchild and not Zeus's child" query
*** query
 X <- every child of Zeus
 Y <- every child of Hera
 Z <- every child of some Y s.t. for all X, X /= Y
*** representation
 [ (X, QFind <child of Zeus> )
 , (Y, QFind <child of Hera> )
 , (Z, QForSome [Y] $ QAnd [ QFind <child of Y>
                           , QForAll [X] $ QTest <Y /= X> ] ) ]
*** algorithm
 For X: do it.
 For Y: do it.
 For Z: For each possible binding of Y
   for each C among the children of Y
     for each possible binding of X -- At this point the subst'n uses 2 vars.
       test whether X == Y
       if at any point they are equal, abort
     if that innermost loop never aborted
       add* the following association the Z-result:
         (Var "C" = C) -> (Var "Y" = Y)
         * where by "add" I mean use insertWith to add (Var "Y" = Y) to the
          set of possible bindings that make (Var "C" = C) valid..
** a variable (here, X) can be quantified existentially in one place and universally in another
*** query
 X <- in children(Zeus)
 Y <- in children(Hera)
 Z <- for some Y, in children(Y)
      & for all X, not equal to X
 W <- for some X, in children(X)
      & for all Z, for all Y(Z), not( has_battled( W, Y(Z) ) )
        Need two forall statements here because Y(Z) is meaningless until Z has a binding.
** disjunctions can make a variable's dependencies on other variables depend on the first one's value
*** The problem
 X <- children of Thor
 Y <- children of Malox
 Z <- for some Y, Z knows Y
      or for some X, Z knows X
 These are every person who knows a child of Thor or a child of Malox. For some values of Z, Y is defined and X not; for other values of Z, X is defined and Y not.
*** It can be solved by rewriting the query
 X <- children of Thor
 Y <- children of Malox
 W <- X or Y
 Z <- for some W, Z knows W

*** The first (problematic) query should be valid
*** But in that case certian result requests are meaningless
 The user cannot ask for X(Z) or Y(Z).
*** Only common dependencies survive disjunction
 When taking the disjunction of two queries, retain any variable dependencies that are defined for every member of the disjunction. So, for instance, if one query is dependent on nothing, then no variable dependencies will be recorded.

*** A simple solution
 In the course of binding variable X, only those bindings the binding depends on will be recorded. This means, for instance, that there might be one value of X dependent on a binding for Y and not on Z, and another binding of X dependent on Z but not on Y. When the user asks for a binding of X that depends on the binding of Y, any binding of X that does not depend on Y will be skipped.
** temporary user burdens: query order, dependency validity
 Eventually the code should be able to determine which queries depend on which others, and whether a sequential solution exists.
