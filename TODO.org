* PIFALLs
** PITFALL: varTestlike ForSomes do not store what they find in the Subst
unlike testlike and findlike queries
** PITFALL: Each mapping in a CondElts can be represented many ways, depending on whether they key is included.
The current idiom is to leave the key out. But -- you could describe a CondElts this way:
 x=1 if (a=1    ) or (b=1    )
or equivalently, this way:
 x=1 if (a=1,x=1) or (b=1,x=1)
or this way:
 x=1 if (a=1    ) or (b=1,x=1)
etc.
** PITFALL: The empty set is nonsense in a CondElts
type CondElts = Map Elt (Set Subst)
  -- ^ Uses `Set` because multiple `Subst`s might obtain the same `Elt`.
  -- PITFALL: If Elt is possible without any other bindings, then
  -- the `Set` should include `M.empty`. If the `Set` is `S.empty`,
  -- it is as if that `Elt` is not in the `Map`.
** PITFALL: Don't let keys collide in a CondElts
If a=1 or a=2 can both lead to b=1, it's tempting to write this:
  (p :: Possible) =
    M.fromList [ (a, ...)
               , (b, M.fromList [ (1, S.singleton $ M.singleton a 1)
                                , (1, S.singleton $ M.singleton a 2) ] ) ]
when it ought to be this:
  (p :: Possible) =
    M.fromList [ (a, ...)
               , (b, M.fromList [ (1, S.fromList [ M.singleton a 1
                                                 , M.singleton a 2 ] ) ] ) ]
** PITFALL : mkVTestIO' : naming error => silent failure
see the comment leading its definition
* TODO PTree
** TODO parts I've checked
ITypes: everything* in it is tested.
  (except getList and setList, which are trivial)
** TODO bugs
cons_focusedViewResult_asChildOfBuffer (M-b from Results window)
** untested functions
All the Buffer functions in UI.BufferTree, RsltViewTree
** ? add a function to check the validity of its focii fields
Only one should be true.
** DONE philosophy, and an alternative
*** it's good enough; use it, probably
 Where slow it can be sped up -- currently, stupidly, it searches outside of an ancestor's focus for the focal descendent.
 I think it will simplify the using code a lot. No checking that paths are valid, for instance.
*** but better would be Data.Tree.Zipper
 Each label on the tree would be an index into the subtree there.
 Those indices would not be a list position, but rather the Addr in an Rslt,
 or some other identifier robust to insertion.
* TODO top priorities
** folding
** things that ought already to work
*** not all Hash functions work
before doing this, do the coder-friendliness task (abstract Rel and Tplt)
*** pExprIsSpecific should address PDiff, PAnd, POr
**** where it is used
  In pRelToHExpr, only specific things can be converted.
  In pMapToHMap, only specific things are retained.
**** how to do it, I think
  if anything in a POr is not specific, then it is not
  if anything in a PAnd is specific, then it is
  if both parts of a Diff are specific, then it is
    Theoretically, the part being subtracted could be vague.
    But that's not how it's implemented -- both parts have to be found,
    then the one is subtracted from the other.
*** pathsToIts_pExpr called on PAnd, POr, PDiff
 probably just return []

 ** incremental view updates
Each time an Expr `e` is added, test each search for whether it would include *only* `e`. Do this by creating a temporary Rslt containing nothing but the terms involved in `e` and the search, and searching in that.
** marking things in a tree
*** buffer nicknames
Let the user add a nickname to a buffer, and then switch to that buffer via the nickname. Begin with some auto-generated nicknames (numbers? letters?).
*** batch add
Toggle a checkbox window at the side of the main window.
Introduce an /each keyword for expression-insertion purposes.
** insertion list
*** data St = ...
+  , _insertionHistory :: [Addr]
*** complications
(1) inserting a compound expression inserts subexpressions
(2) don't record insertion if it already existed
** video
Use screenkey to show key presses:
   https://gitlab.com/wavexx/screenkey#installation-and-basic-usage
and SimpleScreenRecorder.
Audio interface: remember to select both input and output devices.
* user-friendliness
** can insertHosts_atFocus when they're already there
** document the precedence order of the language
and mention that you can use parens liberally to make it more obvious
** show path to here
(Not a big deal because the cursor path is remembered.)
Add a toggleable window above the Results window.
* TODO coder-friendliness
** There should be abstract types Rel, Tplt and Par, used by Expr, RefExpr
and maybe HExpr and PExpr.
This would let me, for example, make ViewCenterRole.vcrTplt :: [Expr] safer.
** wart: HExpr and PExpr are complex and nearly isomorphic
** wart: RsltViewTree is not natural
*** the root
The root is supposed to only be a Query, but that is permitted elsewhere.
The root information is(will be) duplicated by the buffer.
*** the alternation is not enforced
It should be that each ViewResult can only have a Host or Members as a child, and vice-versa.
** ? ditch Vorest, just use vTrees
Easier to have an extra top (data) constructor than a whole parallel (function) infrastructure.
* note order
* views
** count things
** user language
show flag if condition holds
* crawling across Exprs
** Move faster by crossing over some views
When pressing left or right, if there is a view collection like "ViewCenterRole" with no siblings, do not stop on it; cross from its children to its parent, or vice-versa.
** "its members*" (with a star)
all members, submembers, etc -- probably nested
** maybe "its rels*" (with a star)
"maybe" because for certain Exprs that could explode
* UI
** safer open and save
To write, first run `git status`. If anything is modified, ask "are you sure? Your repo has uncommitted changes; saving this data might clobber them."

If it's not a repo, ask, "Are you sure you don't want to turn that data into a Git repo first?"
** crawling within an Expr
up|down to enclosing keyword (/hash, etc)
up|down to nearest higher binop (#, |, etc)
up|down, multipurpose
  this kind goes to either of the two previous kinds of things
left|right in same level
* Hash, the DSL for exprs
** TODO maybe
*** TODO ? _ #? _
 _ #? _ means it could be any kind of binary relationship template.
 _ #? _ #? _ could be any ternary, etc.
*** TODO ? eventually, may need to test PRels for specificity too
The assumption is that a `PRel` always refers to something reasonably specific, because at the very least the template is determined. But with more language features it might not be. (And actually restricting to a certain member will in many cases yield fewer matches than restricting to a certain template.)

 Currently there exists `pExprIsSpecific`, but no `pRelIsSpecific`.
   (`pExprToHExpr` calls `pExprIsSpecific` to find whether conversion is possible.)
   (`pRelToHExpr` calls `pExprIsSpecific` to find which branches to convert.)
*** TODO ? rather than convert PRel to HExpr
 -- just convert it to PMap
 pRelToPExpr :: PRel -> Either String PExpr
 pRelToPExpr Absent = Left "pRelToPExpr: cannot convert Absent."
 pRelToPExpr (PNonRel pnr) = pExprToHExpr pnr
 pRelToPExpr (Closed ms js) =
* Qseq, the search metalanguage
** TODO ? It might be bad that varTestlike ForSomes do not store what they find in the Subst
** TODO ? define not just Sets, but Set-valued functions of Substs
Example (for a singleton Subst): define "ancestors-via-is" as a function of a Var v: It finds everything v' such that (v is v') or (v' is v), then every v'' such that (v'' is v') or (v' is v'') for one of the v's, etc. This allows the set-valued function of v to be referred to by subsequent Queries, without having to recompute the set.
** TODO ? searches that take both Subst and Possible arguments
** TODO ? solve: mkVTestIO': naming errors cause silent failure
*** See the comment leading its definition for detail.
*** TODO why it's tricky
 It would require introducing a type for checking input-output relationships.
 Otherwise there is no record of the names used by the input and the output for validProgram to refer to.
* re. Rslt
** TODO : recursive "is", using "is a kind of"
If "brilliant #(is a kind of) bright", I should be able to search for everything that #is bright, and have brilliant things returned, without needing them to be labeled bright.
** (#fast) isIn ought to return two maps, not a set
a map from Role to Set Addr
   because the item in question often holds the same Role in multiple Exprs
a map from Addr to Set Role
   because the item in question could (although this will be rare) hold
   multiple Roles within the same Expr
** ? To avoid redundant tree-climbing
Recursive calls to a function that evaluates something at an ExprImg by first evaluating it along each of its branches could be expensive. It could be avoided by making the ImgExpr abstract, a functor over some parameter a that is paired with each constructor.
* ? how to make variable collision avoidance easier?
Consider QAnd [ Find child of some x, Test equal to no x].
That's an existential find followed by a universal test over the same variable. The find binds x, then the Test deletes that binding.
The solution is to change the varName in the Test. This puts, however,
an annoying burden on the user.
* ? safety, speed
** for jumping around the view
Could include in the St a map from Addr to Path, so that a user can ask to jump straight to the View corresponding to a given Addr. (If it's in the buffer multiple times, cycle between them.)
** if moving focus ever gets slow
replace those vectors of subviews with zippers
** redundant cases should be last among definitions
example: In this:
    pExprToHExpr :: PExpr -> Either String HExpr
    pExprToHExpr px@(pExprIsSpecific -> False) = Left
      $ "pExprToHExpr: " ++ show px ++ " is not specific enough."
    pExprToHExpr Any =
      Left $ "pExprToHExpr: Any is not specific enough."
I only wrote the Any case to make GHCI not issue a warning. It should come last.
** use lists in some places for fusion, short-circuiting, instead of maps, sets
Example: mapping over a map, and then looking for lefts, is slower than turning the map into a list, mapping over the list, and short-circuiting at the first Left.
hExprToAddrs (the Hash language find routine) called on the HMap constructor, for instance, does this.
** speed when asking for multiple variables that determined a given one
 For varPossibilities, just use the unconditional found values.
 For the input-output criteria, just use VarTest.
*** once that's complete, ditch some unused functions in Subst.hs
*** for more speed, while still pretty simple
(*much* simpler than the input-output-matching varPossibilities strategy I was working on)
Track inputs and outputs. Then, to cut down on the number of varPossibilities tried, allow the user to ask for one flavor (variable name) of input or output to one found Query result. Any additional input-output-matching criteria are imposed via VarTest.
How inputs are tracked (already true):
  Look up a result Var in the Possible.
  In the resulting CondElts, look up a value for the same Var.
  This produces all the possible Substs that could lead there.
How outputs could be tracked:
  Look up an input Var in the Possible.
  In the resulting [?], Look up a value of that Var.
  In the resulting [?], look up the output Var.
  This produces all the possible values that input value could cause in the output.
** speed|space optimization
*** skip recording unneeded dependent bindings
You can tell from reading a Program's [ (VarFunc, Query) ] argument which elements of the Substs will never be referred to; those would not have to be recorded.
** todo ? safety : check that every Set in a CondElts is nonempty
** ? test mixed queries more
*** a ForAll with a ForSome condition
*** a ForAll with a ForAll condition
** test pathsToIts_*, eval
* far off
** synthetic templates
_ is a member of _" is a "synthetic" template. There might be others.
** relationship equivalence
** programmatic edits ("do _ to everything that satisfies _")
** show a recursive statement without exploding
** hard : text-to-hexpr|expr correspondence
** buffer ring
From the Buffer Tree view, allow the user to mark buffers with unique integer indexes. To move "right" in the buffer ring is to move to the buffer with the least index greater than the current one, and left to the one with the greatest index less than, except wrapping at the edges.
* DONE ? overly cautious
** fancy alternatives to Either
 Matt Parsons's magic generic-lens strategy:
   https://www.parsonsmatt.org/2018/11/03/trouble_with_typed_errors.html
 more:
   https://www.fpcomplete.com/blog/defining-exceptions-in-haskell
** TODO maybe: focusPorestOnFocusedPTree
A Porest is a list of PTrees. Exactly one of those PTrees should have focus. This function would move the focus of the Porest to align with the first PTree that has focus.

* DONE explaining some design decisions
** why the focus within the Results window is coded by hand
(where "by hand" = instead of using Brick's built-in focus concept).
*** in brief
Brick's "focus" selects among named Widgets. Few things can be named: lists, editors, viewports and `cached`s. In particular, a strWrap cannot be.

I could wrap the strWrap in a List, but that feels awkward.
*** things that can be named
cached
**** these won't work for holding a single widget
editor
viewport -- would be infinite-sized, because nested
* DONE ? obvious|stale
** forall and exists clauses for variable functions of variables
*** Example
 [ (X, ..)
   (Y,              Exists [X] $ ...)
   (W, Exists [Y] $ ForAll [X(Y)] ...)
   (V, Exists [Y] $ Exists [X(Y)] ...) ]
*** Analysis
 Y, W and V all quantify across some set of Xs.
 Y quantifies existentially across all the Xs.
   It draws those X values from the result of the X query.
 W and V quantify across only those Xs associated with the Y in question.
   They both draw X values the results of the Y query, not the X query.
** the "Hera's grandchild and not Zeus's child" query
*** query
 X <- every child of Zeus
 Y <- every child of Hera
 Z <- every child of some Y s.t. for all X, X /= Y
*** representation
 [ (X, QFind <child of Zeus> )
 , (Y, QFind <child of Hera> )
 , (Z, QForSome [Y] $ QAnd [ QFind <child of Y>
                           , QForAll [X] $ QTest <Y /= X> ] ) ]
*** algorithm
 For X: do it.
 For Y: do it.
 For Z: For each possible binding of Y
   for each C among the children of Y
     for each possible binding of X -- At this point the subst'n uses 2 vars.
       test whether X == Y
       if at any point they are equal, abort
     if that innermost loop never aborted
       add* the following association the Z-result:
         (Var "C" = C) -> (Var "Y" = Y)
         * where by "add" I mean use insertWith to add (Var "Y" = Y) to the
          set of possible bindings that make (Var "C" = C) valid..
** a variable (here, X) can be quantified existentially in one place and universally in another
*** query
 X <- in children(Zeus)
 Y <- in children(Hera)
 Z <- for some Y, in children(Y)
      & for all X, not equal to X
 W <- for some X, in children(X)
      & for all Z, for all Y(Z), not( has_battled( W, Y(Z) ) )
        Need two forall statements here because Y(Z) is meaningless until Z has a binding.
** disjunctions can make a variable's dependencies on other variables depend on the first one's value
*** The problem
 X <- children of Thor
 Y <- children of Malox
 Z <- for some Y, Z knows Y
      or for some X, Z knows X
 These are every person who knows a child of Thor or a child of Malox. For some values of Z, Y is defined and X not; for other values of Z, X is defined and Y not.
*** It can be solved by rewriting the query
 X <- children of Thor
 Y <- children of Malox
 W <- X or Y
 Z <- for some W, Z knows W
*** The first (problematic) query should be valid
*** But in that case certian result requests are meaningless
 The user cannot ask for X(Z) or Y(Z).
*** Only common dependencies survive disjunction
 When taking the disjunction of two queries, retain any variable dependencies that are defined for every member of the disjunction. So, for instance, if one query is dependent on nothing, then no variable dependencies will be recorded.
*** A simple solution
 In the course of binding variable X, only those bindings the binding depends on will be recorded. This means, for instance, that there might be one value of X dependent on a binding for Y and not on Z, and another binding of X dependent on Z but not on Y. When the user asks for a binding of X that depends on the binding of Y, any binding of X that does not depend on Y will be skipped.
** temporary user burdens: query order, dependency validity
 Eventually the code should be able to determine which queries depend on which others, and whether a sequential solution exists.
