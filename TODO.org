* DISCLAIMER: This document is
not really intended to be understood by anybody but myself.
For documentation, please see the README.md file.
If that's not enough, check out the docs/ folder.
* PTIFALL: stack gchi: if no libraries are available
https://github.com/commercialhaskell/stack/issues/5037
This will load all non-broken modules when some are broken.
  stack exec -- ghci -Wall
  :l Hode.Hode
* backup the data repo(s)
* TODO critical
** TODO document
*** TODO resume doc QA at
ui.md # Keyboard commands
*** TODO better intro
Explain that to use it, you don't need to know any Hash except how to use #.
The rest is just for doing fancy searches.
*** TODO align the interactive help with the docs/ folder
*** TODO ensure orphans are covered
**** # operator precedence
We can vary the number of hash symbols attached to a separator to indicate how high a relationship is.
This is optional, but it makes things easier to read.
For instance, the previous relationship could be written without parentheses as
`Mary ##knows Bill #likes Sue`.

When you're writing data into a `Rslt` you can use either style,
parentheses or multiple hashmarks, to structure an expression.
You can even mix them both in the same expression.
*** TODO add hyperlinks
Could stick in the markdown easily.
Not so easy in the app.
*** TODO IMPORTANT documentation: order of topics
**** TODO Hash ops:
Important because if set ops are introduced before /eval,
either it's confusing or they look useless.
***** fundamental: #, /_, /t, /ts, /@
***** set ops
***** subexpr matching
  /member: with top-level sub-expr
  /involves: with sub-expr at depth
  /eval: find expr, return subexpr
  /it: id subexpr in expr
  /it=: id & limit subexpr in expr
  /map: map roles to exprs
***** order & transitivity
  reach, transLeft, transRight
*** TODO verify hyperlinks
*** TODO verify docs/ coverage
*** maybe the # parser should be treated specially
and the "slashPrefix" field dropped.
*** ? these features
are already in the interactive help
select ViewExpr (M-X)
nudging (M-E, M-D)
deleting buffers
** TODO ? multi-line expressions
** TODO check for cycles when a tplt is declared transitive
Check for cycles non-locally --
that is, with reference to no particular point in the cycle.
* TODO critical but can wait until after beta release
** TODO shrink memory footprint, git-compatible, keep timestamps
Aggregate data into fewer files.
After each node ID, keep its creation date and its last modified date.
That way a little awk or something can find me the diff history of that node,
without bringinng the history of everything else with it.
** TODO batch add
/a (patience | humor) #is-a (virtue | skill)
** TODO save should first delete all .rslt files
** permit scrolling
*** in the main help window
*** in the history window
*** if I want a scrollbar
 Maybe Brick offers one as part of a viewport.
 If not, could instead indicate, e.g., "Item 3 of 5" near menus.
** modes and keymap
*** help mode: make the submode menu optional
If there's only one choice in that layer, hide it.
*** implement new commands
M-w e - <new> Show error "buffer". (Why is this not a proper buffer?)
M-w r - <new> Toggle reassurance window.
???   - Toggle the "press Alt-? for help" window.
** TODO the obstructive subexpression problem
*** EASY: the "don't show X in maybe X" problem
Just add some more indicators to _columnHExprs:
  not, maybe, and warning
*** after using the app more, maybe consider the more general problem
** TODO change: can insertHosts_atFocus when they're already there
** TODO folding indicator
Visually indicate whether a node with descendents is folded.
Or at least, upon inserting contents, unfold.
** TODO ? compress binary groups
** manual update
* TODO unsorted
** TODO BUG: does the ui insert "\n" at the end of user commands?
 In open code, this always works:
   MP.parse _pHashExpr "" "a # /_ "
 But in the ui, "/f a # /_" generates a parse error
   if nonPrefix is not checking for \n.
*** changing the definition of nonPrefix "fixes" it
 but undoes the reasons that I made those changes.
 Namely, set it back to `... <* notFollowedBy alphaNumChar`
*** TODO learn how lexing works
 The problem is that I've absorbed the detection of parens and quotation marks
 (and space?) into the parsers for individual terms.
** TODO restore: there used to be a way to switch to the error buffer
It was `M-e` or `M-E`.
** TODO ? use BiMap to associate Addrs and Exprs
** ordering
*** TODO ? BUG : when removing from an order, connect any gaps created
(The relevant function is removeSelections_fromSortedRegion.)
So far it disconnects the to-be-removed from the still sorted,
and mutually disconnects everything in the to-be-removed.
*** TODO BUG in sort
**** a way to trigger it
 /a a # b # c # d
 /f a # b # c # d
 <view members>
 /a (a # c) # (c # b)
 /sr (/t /_ "" /_)
**** the problem
 kahnSort deletes expressions from a copy of the graph.
 Deletion something that's a member of other things is not permitted.
**** the solution, I think
 is to create and use an "unsafeDelete" which does not check for membership in superexpressions.
 I think this works because in the course of sorting we never need to find anything's subexpressions.
*** TODO ? a function to "iron" an order into place
A graph can in general have multiple ways to be topologically sorted.
Therefore, when the user sees a set of ordered expressions,
and A > B on screen,
it could be that A is not truly > B. (It can't, however, be that A < B.)
To "iron" a subset of an order would be to create a chain through them all,
such that the order in which they appear on screen is indeed the only reasonable order among them.
*** display
**** the highlight should not affect the columns, only the payload
**** more expressive sort-colors
***** there are currently these two categories
Involved in the relationship -- even if its partner is not in this list.
Not involved in the relationship.
***** There should be these four categories.
****** with no transitive relation (TR) to the others
 black, last
****** with some TR to the others, but not *this* TR
 that is, not related to anything else in the list by the TR that currently orders the list
****** related to others in the list by the TR ordering the list
****** related to others *not* in the list by the TR ordering the list
**** by default, sort by the first applicable sort criterion
 in each group of search results -- top-level or otherwise.
 Change ExprTree.insertSearchResults_atFocus
   based on RunParsed.runParsedCommand
**** indicate the sort applied to each view-fork
e.g. in parens, following the name of the fork
or with a typed-in command that shows it in the reassurance window.
**** DONE , right? keyboard command to change the sort on a group
***** later, a "sort program" buffer
Specific to a given VExpr, applied to its children.
Shows every TR, and a checkbox next to the one curently ordering the list.
The checkbox can be moved.
*** ? needs a closure algorithm
Suppose [a,b,c] are to be shown, and a > b, and c > d.
None of them are isolated from the closure of (>),
but among [a,b,c], c is isolated.
It should be shown in the unsorted group.
*** ? compromise: don't consider non-local connections
** TODO rewrite the PTree class
*** the new type
It can be like Data.Tree.Zipper, but using PointedLists (Plists).
The focus and its peers are represented as a PList of PTrees.
The ancestors are represented like in Data.Tree.Zipper:
each is a (reversed [PTree a]) a [PTree a].
Moving sideways is just a PList op.
Moving up or down requires converting one level between the PList and ancestor representations.
*** TODO first survey how I use it
It's only used in Hode.UI.
Potentially tricky:
  building a tree from the top while knowing where the focus is.
  Optics (refer to the PointedList implementation).
** TODO establish an informal schema
*** TODO Is (#maybe _) different from (#question _)?
(#question _) seems more general -- it permits non-boolean members.
*** AMR might be useful
 https://github.com/nschneid/amr-tutorial/raw/master/slides/AMR-TUTORIAL-FULL.pdf
 (in my Downloads/ folder)
** TODO optic ideas
*** Tree has an Ix class.
 I could write one for the Rslt, which might make following paths easier.
*** TODO are there other getters I should rewrite as folds?

** TODO is PTree focus buggy?
 When I run `st <- ui`, look through a small view-tree,
 and then exit and study `st`, I find many nodes for which `pTreeHasFocus`
 is `True`. This seems to contradict a comment in PTree.Initial, that
 "If it has focus, none of its children should."
** TODO unify cyclesInvolving, connections, and things yet to write
 something yet to write: like connections or cyclesInvolving, but it only returns the first thing it finds, rather than all of them.

 cyclesInvolving returns a set of cycles (whole paths), which is inefficient in its only current use context, the CycleBuffer. It should only return one.

 reachable gives everything reachable from a set of origins; the target set is unrestricted. It doesn't give the path, just the destination.
* TODO pressing
** TODO tests for the UI
*** St could be Eq and Ord
if I made (probably orphan) instances for Brick.Widgets.Edit.Editor
** TODO error window: Why is it treated differently?
** TODO reading and navigation are slow
*** would help: hide in context
in the context of golf, any phrase ending in "of golf"
can be omitted
**** how not to repeat a context?
 My data currently includes (fake addresses):
   @1: extend ##o columns #of hode
   @2: #to @1 #do ...

 As it stands that's fine,
 but I would like to create a Hode to-do list:
   @3: #for hode #do @1
 i.e.
   @3: #for hode #do (extend ##o columns #of hode)
*** would help: synonyms
*** would help: don't group single items
*** might help ? better columns
Some as counts, some otherwise.
*** might help ? distinguish "of interest" expressions
** TODO templates for sets of arbitrary size
** count more stuff in the left column(s)
*** ? use hMatches
*** let the user add HExprs to _columnHExprs
*** let each HExpr column be given a title
*** let each buffer keep its own list of HExprs
*** indicate matches ala chmod
A single decimal (hex) digit can indicate whether an `Expr`
matches up to 3 (4) separate `HExpr`s.
** TODO filters, throughout the view-Porest
not just its top level
* TODO easy
** TODO use HasCallStack to mark partial functions.
 https://www.tweag.io/posts/2020-04-16-exceptions-in-haskell.html
** TODO don't print zeroes in the columns
** TODO insertion list
*** plan
**** data St = ...
+  , _insertionBuffer :: Buffer
**** initially, just add the final result of insertions
**** then refactor insertion so it returns the full history of added things
*** complications
(1) inserting a compound expression inserts subexpressions
(2) don't record insertion if it already existedx
** TODO the color "white text on black background"
** TODO new in GHC 8.10: :instances
Given a type, shows its classes.
** TODO shortcut to empty the command window
was implemented already once
** TODO merge two nodes
*** why
e.g. because (and why can this happen?)
two identical templates exist at different addresses.

For an example of that error,
see jbb/ until (but not after)
commit 15201a6561b4181695f72bcb176136f43c94f853
*** how
If they are not identical, one of them is the "survivor".
They can be templates, if they have the same arity.
** TODO upon save, delete unused phrases and templates
unless maybe it's a long phrase
PITFALL: But don't delete the empty string.
         Or maybe the need for the empty string is obsolete?
* TODO big-think
** soft
*** who cares?
**** TODO Projects with extremely similar goals
***** "Knowledge Representation" research community
https://en.wikipedia.org/wiki/Knowledge_representation_and_reasoning
***** Agora
 Extremely similar goals, envisioned user experience.
 https://flancia.org/agora/
***** Perkeep
 Extremely similar goals.
 https://perkeep.org/
***** Cyc
knowledge base for AI
https://en.wikipedia.org/wiki/Cyc
**** TODO websites for announcing stuff
https://app.ryeboard.com/card/92672dba-a4a8-4be0-88db-b4feca771afa
https://news.ycombinator.com/item?id=21812786
**** "convergence"
 https://link.springer.com/article/10.1007/s11051-019-4638-7?wt_mc=Internal.Event.1.SEM.ArticleAuthorIncrementalIssue&utm_source=ArticleAuthorIncrementalIssue&utm_medium=email&utm_content=AA_en_06082018&ArticleAuthorIncrementalIssue_20191108&fbclid=IwAR08OarPih1ava0yDKrM_PK07xLSZ2ZSV_bzmvukc7RpNzQQHNzvRa8qxs8
**** fake news
 https://www.fakerfact.org/about
**** "navigating digital information"
 https://www.youtube.com/watch?v=M5YKW6fhlss&list=PL8dPuuaLjXtN07XYqqWSKpPrtNDiCHTzU&index=11
**** distributed search
*** am I stumped as a user?
 The number of ways to represent something is huge.
 Paralyzingly huge.
*** if I'm ambivalent about (currently) implementing a fewature
 Use the software, wait for a use case to arise,
 document the use case under the "todo" item.
** representing things
*** unordered "set tplts" of variable size
As in "A + B + ... = C", or "A & B & ... => X"
*** anticipate whether a sub-expression will be "needed"
where "needed" can be
  searched for
  needed for readability
*** name conflicts
It would be better if distinct things could share a name.
** problems
*** it's hard to judge without an interesting graph
**** would help: smsn
** types?
* TODO user-friendliness
** TODO crawling within an Expr
up|down to enclosing keyword (/hash, etc)
up|down to nearest higher binop (#, |, etc)
up|down, multipurpose
  this kind goes to either of the two previous kinds of things
left|right in same level
** TODO a regex index
** TODO If there's a cycle, announce it everywhere
at the top of every window except the Error window.
** TODO edit a PTree
*** Annotate things.
*** delete parent from any PTree
and move children up to where it was
** TODO wrapping is buggy
*** example
For instance, the display of this (at address 153 in jbb/)
   ###re ##solve tmux #has-problem sometimes the status bar is cluttered ##by keep only window names ###note-that status-right #can put any label at the right of the status bar, e.g. the current time.
includes a 121-character-long line.
*** todo ? distance to wrap should shrink with columns, indentation
*** todo ? temp fix: allow user to change wrap length
** TODO ? offer to delete orphaned nodes
If a member of something deleted is not remember of anything else, ask whether to delete it, too -- and recurse.
** TODO copy to clipboard: buggy on Nix
On Nix it represents newlines the wrong way.
** TODO shortcut: copy address
** TODO ? back-references for searches encoded as Exprs
When a new node is added that matches an extant search,
the search will find it, but (without further work)
it will not find the search as a neighbor.
** TODO ? wart: monodirectionality in `reachable`
It can accept multiple `Tplt`s to search along,
but only a single `SearchDir`.
** safer open and save
To write, first run `git status`.
If anything is modified, ask "are you sure? Your repo has uncommitted changes; saving this data might clobber them."

If it's not a repo, ask, "Are you sure you don't want to turn that data into a Git repo first?"
** document the precedence order of the language
and mention that you can use parens liberally to make it more obvious
** show path to here
(Not a big deal because the cursor path is remembered.)
Add a toggleable window above the Results window.
* TODO HExpr: extend HMember and HInvolves
** implement HMember-Star
which searches to arbitrary depth
** Permit them to be inside `HEval`s
Involves does not play nicely with pathsToIts.
Even the Involves that only goes 1 layer deep is confusing.
Once it is implemented, Paths needs to not be integers lists;
they will have to be lists of (Integer | Wildcard),
where a Wildcard stands for "any number could go here".
* PIFALLs | warts
** TODO searching for a Tplt with empty-string separators
One needs to represent the empty separator as \"\", as in this:
   Right r = nInserts (mkRslt mempty) [ "0 # 1", "1 # 2" ]
   t = nFind r "/t /_ \"\" /_"
** in Qseq
*** PITFALL: varTestlike ForSomes do not store what they find in the Subst
 unlike testlike and findlike queries
*** PITFALL: Each mapping in a CondElts can be represented many ways, depending on whether they key is included.
 The current idiom is to leave the key out. But -- you could describe a CondElts this way:
  x=1 if (a=1    ) or (b=1    )
 or equivalently, this way:
  x=1 if (a=1,x=1) or (b=1,x=1)
 or this way:
  x=1 if (a=1    ) or (b=1,x=1)
 etc.
*** PITFALL: The empty set is nonsense in a CondElts
 type CondElts = Map Elt (Set Subst)
   -- ^ Uses `Set` because multiple `Subst`s might obtain the same `Elt`.
   -- PITFALL: If Elt is possible without any other bindings, then
   -- the `Set` should include `M.empty`. If the `Set` is `S.empty`,
   -- it is as if that `Elt` is not in the `Map`.
*** PITFALL: Don't let keys collide in a CondElts
 If a=1 or a=2 can both lead to b=1, it's tempting to write this:
   (p :: Possible) =
     M.fromList [ (a, ...)
                , (b, M.fromList [ (1, S.singleton $ M.singleton a 1)
                                 , (1, S.singleton $ M.singleton a 2) ] ) ]
 when it ought to be this:
   (p :: Possible) =
     M.fromList [ (a, ...)
                , (b, M.fromList [ (1, S.fromList [ M.singleton a 1
                                                  , M.singleton a 2 ] ) ] ) ]
*** PITFALL : mkVTestIO' : naming error => silent failure
 see the comment leading its definition
* might come back to haunt me
** pExprIsSpecific should address PDiff, PAnd, POr
*** where it is used
 In pRelToHExpr, only specific things can be converted.
 In pMapToHMap, only specific things are retained.
*** how to do it, I think
 if anything in a POr is not specific, then it is not
 if anything in a PAnd is specific, then it is
 if both parts of a Diff are specific, then it is
   Theoretically, the part being subtracted could be vague.
   But that's not how it's implemented -- both parts have to be found,
   then the one is subtracted from the other.
* video
Use screenkey to show key presses:
   https://gitlab.com/wavexx/screenkey#installation-and-basic-usage
and SimpleScreenRecorder.
Audio interface: remember to select both input and output devices.
* coder-friendliness
** to include arity in the a node's type
see digraphs-with-text/gadt.hs
** TODO simplify result of nPExpr
e.g. if q = "/trr 1 #< (/it= 0 | 2)", then
nPExpr q = Right ( PRel $ PNonRel $ ...
** TODO ? separate State and UIState, and use State in NoUI
type ColumnProps = Map HExpr Int
data OtherProps = OtherProps {
  _folded :: Bool -- ^ whether the ViewExprNode's children are hidden
  } deriving (Show, Eq, Ord)
data St = St {
    _searchBuffers          :: Maybe (Porest Buffer)
  , _columnHExprs           :: [HExpr]
  , _appRslt                :: Rslt
  }
** wart: ifLefts and LeftStrings
*** could be replaced with Data.Validation
which comes with toEither and fromEither
https://www.reddit.com/r/haskellquestions/comments/d4f6px/class_should_apply_to_a_functor_only_when_its/
*** LeftStrings could be more polymorphic
https://www.reddit.com/r/haskellquestions/comments/d4f6px/class_should_apply_to_a_functor_only_when_its/
** wart ? HExpr and PExpr are complex and nearly isomorphic
** wart: RsltViewTree is not natural
*** the root
The root is supposed to only be a Query,
but that is permitted elsewhere.
The root information is(will be) duplicated by the buffer.
*** the alternation is not enforced
It should be that each ViewResult can only have a Host or Members as a child,
and vice-versa.
* TODO views
** TODO marking things in a tree
*** buffer nicknames
Let the user add a nickname to a buffer,
and then switch to that buffer via the nickname.
Begin with some auto-generated nicknames (numbers? letters?).
*** batch add
Toggle a checkbox window at the side of the main window.
Add (_isChecked :: Bool) to OtherProps.
Introduce an /each keyword for expression-insertion purposes.
** automatic update
*** goal
Each time an Expr `a` is added,
test each search for whether it would include *only* `a`.
*** method
Call each layer in each ViewTree a "spot".
Each is associated with some kind of Hash expression `h`.
Decompose `h` into its constituents, and save those at the spot.

When an Expr `a` is added, break that into its constituents too.
Then, for each spot, create a Rslt `r` consisting of
(1) the constituents of `e`, and
(2) the constituents of the hash expression associated with that spot.
Now search r for h,
and add (in the map-insertion sense)
anything found to the contents already at h.
** store views
e.g. mark HostGroups as salient,
and store that info,
and permit viewing only the salient ones
** user language
show flag if condition holds
* crawling across Exprs
** Move faster by crossing over some views
When pressing left or right,
if there is a view collection like "ViewCenterRole" with no siblings,
do not stop on it.
Instead cross from its children to its parent, or vice-versa.
** "its members*" (with a star)
all members, submembers, etc -- probably nested
** maybe "its rels*" (with a star)
"maybe" because for certain Exprs that could explode
* Hash & maybe
** TODO ? _ #? _
_ #? _ means it could be any kind of binary relationship template.
_ #? _ #? _ could be any ternary, etc.
** TODO ? eventually, may need to test PRels for specificity too
The assumption is that a `PRel`
always refers to something reasonably specific,
because at the very least the template is determined.
But with more language features it might not be.
(And actually restricting to a certain member will in many cases yield fewer matches than restricting to a certain template.)

 Currently there exists `pExprIsSpecific`, but no `pRelIsSpecific`.
   (`pExprToHExpr` calls `pExprIsSpecific` to find whether conversion is possible.)
   (`pRelToHExpr` calls `pExprIsSpecific` to find which branches to convert.)
* TODO Qseq, the search metalanguage
** TODO ? It might be bad that varTestlike ForSomes do not store what they find in the Subst
** TODO ? define not just Sets, but Set-valued functions of Substs
Example (for a singleton Subst): define "ancestors-via-is" as a function of a Var v: It finds everything v' such that (v is v') or (v' is v), then every v'' such that (v'' is v') or (v' is v'') for one of the v's, etc.
This allows the set-valued function of v to be referred to by subsequent Queries, without having to recompute the set.
** TODO ? searches that take both Subst and Possible arguments
** TODO ? solve: mkVTestIO': naming errors cause silent failure
*** See the comment leading its definition for detail.
*** TODO why it's tricky
It would require introducing a type for checking input-output relationships.
Otherwise there is no record of the names used by the input and the output for validProgram to refer to.
** ? how to make variable collision avoidance easier?
 Consider QAnd [ Find child of some x, Test equal to no x].
 That's an existential find followed by a universal test over the same variable. The find binds x, then the Test deletes that binding.
 The solution is to change the varName in the Test. This puts, however,
 an annoying burden on the user.
* TODO re. Rslt
** TODO relationship equivalence
** TODO symmetric relationships (includes isomorphisms)
** TODO ? multi-Tplt topological sort
tags: order, transitive
*** if I could identify a set of tied w/r/t tplt-1 tops
then I could sort them by tplt 2, etc.
I suspect I could do this by:
  (1) scan the graph for everything that's top. They are tied.
  (2) When picking off those tied things, if anything becomes top,
      don't stick it at the end of the same list.
      Rather put it in a new list. That list will then consist of ties, too.
  (3) Repeat until done.
This is especially nice because it means I can just code the single-tplt sort for now,
and later, if need be, implement multi-tplt sort in terms of it.
*** maybe see earlier-work/lexico-topo-sort
Most of that work, though, describes a wholly different algorithm.
I would prefer this one, if it really does make sense.

** transitive search
*** DONE rethinking purpose
**** problem: HExpr finds Exprs; while transitive search finds pairs
Those pairs might be explicitly in the graph, but might not.
**** `reachable` will be easier to implement than `transitiveRels`
When running `reachable`,
which takes no fixed terminal arguments,
you want the whole lot (including starting points).
**** `transitiveRels` resembles `HEval`
When running `transitiveRels`,
which fixes start and end Exprs,
you probably want one or the other --
show me each of these starts that can reach one of these ends,
or each end that can be reached from some start.
But you might want both.

It would therefore be natural to include a [Role] argument to HTrans.
Unlike HEval, which takes a [RolePath],
these "paths" are necessarily length 1,
and there are only two possibilities: RoleMember 1 and RoleMember 2.
Also, confusingly,
*they don't index into the members of a relationship in the graph*;
they index into a pair constructed by `transitiveRels`.
*** TODO orphans
**** TODO ? could introduce type TransRole = TransLeft | TransRight
to limit the possible values in the list argument of PTrans (because,
e.g., RoleMember 3 or RoleTplt make no sense)
**** TODO efficiency: transitiveRels might, but HTrans does not have to search exahstively
See TODO comment under the HTrans clause of hExprToAddrs.
transitiveRels does have to find every pair if, for example, it's computing a transitive closure (as will be needed to oganize contents on-screen).
**** TODO Safety: check for cycles when someone adds an expression
**** TODO the transitive rel functions should take (SearchDir, Tplt) pairs
rather than a single SearchDir and multiple Tplts.
But this can wait until I need that.
**** TODO store, for each rel, the better traversal direction
Maybe use QuickCheck to automate the discovery of that direction.
  Run in the background each time a new
  instance of a transitive relationship is added.
The user should still be able to specify direction if needed.
  It's conceivable that a relationship might usually be best traversed left,
  but not always.
*** thinking | difficulties
**** two-template transitivity
***** "(x #is y) #and (y #(is subclass of) b) ##implies x #is z
**** equals, isa, is | hasq(uality), hasa
**** kinds of order
linear (schedule) vs. branching (dependency)
overlapping
topological sort
**** reflexivity is, so far, implicit
"Transitive" in Hode really means "transitive + reflexive".
*** done | stale
**** DONE the algorithm
***** use Hode.Data.Map.compose
***** DONE easiest algorithm: user chooses which way to search
 Given sets X and Y, we want all (x,y) s.t. x < y.
 wolog, suppose the user chooses to search "increasing|rightward".
 Define (\) to be the set difference operator:
 X \ Y is the set X, minus its intersection with Y.

 Let X1 be all n such that for some x in X \ Y,
   (x < n) is (explicitly) in the graph,
 and let pred_1 :: X1 -> 2^X map every x1 in X1 to {x in X s.t. x < x1).
   (Use Hode.Hash.HLookup.)
 Let X2 be all n such that for some x in X1 \ Y, (x < n) is in the graph,
 and pred_2 :: X2 -> 2^X map every x2 in X2 to {x in X s.t. x < x2).

 Similarly, build sets X3, X4 ... Xn,
 and functions pred_3, pred4 ... pred_n,
 such that X(n+1) would be the first empty one.

 Define XM = X union X1 union ... union Xn.
 Define earliestAncestors :: XM -> X.
 (If x is in X, then x is in `earliestAncestors x`,
 but it might not be the only member.)

 Find I = XM intersect Y.
 For each y in I,
 for each x in `earliestAncestors y`,
 include (x,y) in the answer.
***** goal
 The search might be "reflexive" (<=) or not (<).
 Given two sets X and Y, we search left from X, right from Y,
 for a set P = {(x,y) : x (<=|<) y}.
**** goal: transitive search
 If "brilliant #(is a kind of) bright",
 I should be able to search for everything that #is bright,
 and have brilliant things returned,
 without needing them to be labeled bright.
**** method
***** TODO ? Build-in some Exprs
 Phrase "transitive"
 Tplt "_ is _"
***** Search query format: unchanged
 They look just like they used to.
 But if "_ x _" is transitive, then searching for "/any #x y"
 will (potentially) return more stuff.
***** TODO better: hand this work off to some existing library
****** basic idea
 Find all the xs and all the ys.
 Use the graph (whose nodes are addresses) induced by the #r relationship.
****** TODO There are haskell bindings for a few graph querly langs now
 gremlin
 graphql
 pangraph
 cayley
****** graphite, Graphalyze look good
 *graphite* uses hash maps
 *Data.Core.Graph* "is fast, efficient", uses IntMap
 Data.Graph.Comfort uses Data.Map, but it's a one-page library
 digraph - hashmaps, three modules
****** if x is /any but y is specific (or vice-versa)
 Compute `Data.Graph.reachable y` for every value of y.
***** nah - hand-write the search algorithm for "x #r y"
****** If x is /any but y is specific (or vice-versa)
 Find everything that would be in "x #r y" without transitivity.
 Call that s1.
 For each (m1 #r y) in s1, search for "/any #r m1",
 and call the result "m2 #r m1".
 Call the set { m2 #r y } "s2 of y".
 Repeat: for each m2 in (s2 of y), search for "/any #r m2",
 and call each result "m3 #r m2" ...
 Eventually, end up with a bunch of relationships of the form "x #r y".
****** If neither is specific
 Fuck that. Just return what's been getting returned already,
 which is just the first-order (ignoring transitivity) relatinoships.
 To return all the transitive relationships
 would be both hard for the programmer and useless for the user.
****** *DOPE* If both are specific
 Let X = {x} and Y = {y}
 Create an empty map M from X to Y.

 Let X1 be all the values reachable from X in one rightward hop.
 Create a map L1 (L stands for left) from X1 to X,
 indicating which members are connected.
 For every y in both X1 and Y, add (L1 y, y) to M.

 Let Y1 be all values reachable from Y in one leftward hop.
 Create a map R1 (R stands for right) from Y1 to Y.
 For every x in both Y1 and X, add (x, R1 x) to M.
 *NEW at this step*: For every x in both Y1 and X1, add (L1 x, R1 x) to M.

 Let X2 be all values reachable from X1 in one rightward hop.
 *NEW IDEA* Using L1, create a map L2 from X2 to X.
 For each y in both X2 and Y, add (L2 y, y) to M.
 For each y in both X2 and Y1, add (L2 y, R1 y) to M.

 This has to go on until both forests are completely mapped.
***** wart: What if you don't want to use the transitivity?
****** fortunately there's a hack that solves it
 The user can just temporarily delete the transitivity property for that Tplt.
****** the problem
 If "_ x _ " is transitive, and one searches for "/_ #x /_",
 the user probably just wants to see all the first-order x relationships,
 not the compound ones.

 This suggests either treating that (and similar?!) case specially,
 or letting the user ask not to use the transitivity.
**** suspicions
***** The functions in Hash.HLookup deserve complication for transitivity.
 Hash, after all, is the query language,
 and in that language transitive search is a distinct concept.
** (#fast) isIn ought to return two maps, not a set
a map from Role to Set Addr
   because the item in question often holds the same Role in multiple Exprs
a map from Addr to Set Role
   because the item in question could (although this will be rare) hold
   multiple Roles within the same Expr
** stale ? To avoid redundant tree-climbing
Recursive calls to a function that evaluates something at an ExprImg by first evaluating it along each of its branches could be expensive.
It could be avoided by making the ImgExpr abstract, a functor over some parameter a that is paired with each constructor.
* ? safety, speed
** TODO add tests
tag untested
*** searching for OR should not fail if some terms do
test hMatches and hLookup (in Hode.Hash.HLookup)
*** test pathsToIts_*, eval
*** Hode.Util.PTree.writeLevels
** To use GHC 8.10's newer garbage collector
https://well-typed.com/blog/2019/10/nonmoving-gc-merge/
Our new collector has been merged to GHC’s master branch and will be present in GHC 8.10.1. For a program to use the concurrent non-moving collector it must be compiled with GHC’s -threaded flag and invoked with the +RTS -xn runtime system flag.
** ? someone wrote a tree editor
https://cs-syd.eu/posts/2019-06-28-microsmos
and then a forest editor:
https://cs-syd.eu/posts/2019-08-28-millismos
** TODO ? use lists rather than sets until needed
e.g. in HExprToAddrs, or the RLookup functions.
That is, unless set fusion works as well.
*** use lists in some places for fusion, short-circuiting, instead of maps, sets
 Example: mapping over a map, and then looking for lefts, is slower than turning the map into a list, mapping over the list, and short-circuiting at the first Left.
 hExprToAddrs (the Hash language find routine) called on the HMap constructor, for instance, does this.
** there are some list-set mismatches
rightReachable, for instance, uses lists, because it's fast.
But it has to convert the output of hExprToAddrs to a list, using Set.toList.
It would be nice if a version of hExprToAddrs existed that used lists, not sets.
** for jumping around the view
Could include in the St a map from Addr to Path, so that a user can ask to jump straight to the View corresponding to a given Addr.
(If it's in the buffer multiple times, cycle between them.)
** redundant cases should be last among definitions
example: In this:
    pExprToHExpr :: PExpr -> Either String HExpr
    pExprToHExpr px@(pExprIsSpecific -> False) = Left
      $ "pExprToHExpr: " ++ show px ++ " is not specific enough."
    pExprToHExpr Any =
      Left $ "pExprToHExpr: Any is not specific enough."
I only wrote the Any case to make GHCI not issue a warning.
It should come last.
** QSeq: speed when asking for multiple variables that determined a given one
For varPossibilities, just use the unconditional found values.
For the input-output criteria, just use VarTest.
*** once that's complete, ditch some unused functions in Subst.hs
*** for more speed, while still pretty simple
(*much* simpler than the input-output-matching varPossibilities strategy I was working on)

Track inputs and outputs.
Then, to cut down on the number of varPossibilities tried, allow the user to ask for one flavor (variable name) of input or output to one found Query result.
Any additional input-output-matching criteria are imposed via VarTest.

How inputs are tracked (already true):
  Look up a result Var in the Possible.
  In the resulting CondElts, look up a value for the same Var.
  This produces all the possible Substs that could lead there.
How outputs could be tracked:
  Look up an input Var in the Possible.
  In the resulting [?], Look up a value of that Var.
  In the resulting [?], look up the output Var.
  This produces all the possible values that input value could cause in the output.
** QSeq: speed|space optimization
*** skip recording unneeded dependent bindings
You can tell from reading a Program's [ (VarFunc, Query) ] argument which elements of the Substs will never be referred to; those would not have to be recorded.
** QSeq: todo ? safety : check that every Set in a CondElts is nonempty
** QSeq: ? test mixed queries more
*** a ForAll with a ForSome condition
*** a ForAll with a ForAll condition
** TODO save disk space w/ multi-line files
*** demonstrating the problem: one-file-per-statement is wasteful
 [jeff@jbb-dell:~/code/rslt/hode/jbb/temp]$ ls
 0.rslt   21.rslt  30.rslt  41.rslt  4.rslt   58.rslt  66.rslt  74.rslt  87.rslt  9.rslt
 11.rslt  22.rslt  32.rslt  42.rslt  50.rslt  59.rslt  67.rslt  75.rslt  88.rslt
 14.rslt  23.rslt  35.rslt  43.rslt  51.rslt  5.rslt   68.rslt  7.rslt   89.rslt
 15.rslt  24.rslt  36.rslt  44.rslt  52.rslt  60.rslt  69.rslt  80.rslt  8.rslt
 17.rslt  25.rslt  37.rslt  45.rslt  53.rslt  61.rslt  6.rslt   81.rslt  90.rslt
 18.rslt  26.rslt  38.rslt  46.rslt  54.rslt  62.rslt  70.rslt  83.rslt  91.rslt
 19.rslt  27.rslt  39.rslt  47.rslt  55.rslt  63.rslt  71.rslt  84.rslt  92.rslt
 1.rslt   28.rslt  3.rslt   48.rslt  56.rslt  64.rslt  72.rslt  85.rslt  93.rslt
 20.rslt  2.rslt   40.rslt  49.rslt  57.rslt  65.rslt  73.rslt  86.rslt  94.rslt

 [jeff@jbb-dell:~/code/rslt/hode/jbb/temp]$ du -hs .
 332K    .

 [jeff@jbb-dell:~/code/rslt/hode/jbb/temp]$ for i in *; do echo $i $(cat $i) >> test; done

 [jeff@jbb-dell:~/code/rslt/hode/jbb/temp]$ du -hs test
 4,0K    test

 [jeff@jbb-dell:~/code/rslt/hode/jbb/temp]$ head test
 0.rslt p ""

 11.rslt p "see"
 14.rslt r [9,15] 17)
 15.rslt p "https://github.com/commercialhaskell/stack/issues/5037"
 17.rslt t (Just 65) [11] Nothing)
 18.rslt p "is-a"
 19.rslt t Nothing [18] Nothing)
 1.rslt p "has-problem"
 20.rslt p "template haskell"
 21.rslt p "extension"
* far off
** synthetic templates
"_ is a member of _" is a "synthetic" template. There might be others.
** programmatic edits ("do _ to everything that satisfies _")
** show a recursive statement without exploding
** hard : text-to-hexpr|expr correspondence
** buffer ring
From the Buffer Tree view, allow the user to mark buffers with unique integer indexes.
To move "right" in the buffer ring is to move to the buffer with the least index greater than the current one, and left to the one with the greatest index less than, except wrapping at the edges.
* TODO collect use cases
** view notes from a text ordered by source text or topic
** collective note taking
https://blogs.agu.org/geoedtrek/2016/12/28/collaborative-note-taking/
** google isn't that great
https://news.ycombinator.com/item?id=21515181
https://stratechery.com/2019/the-google-squeeze/
* DONE ? overly cautious
** fancy alternatives to Either
 Matt Parsons's magic generic-lens strategy:
   https://www.parsonsmatt.org/2018/11/03/trouble_with_typed_errors.html
 more:
   https://www.fpcomplete.com/blog/defining-exceptions-in-haskell
** more safety with PTree focus
*** a function to check the validity of its focii fields
*** focusPorestOnFocusedPTree
A Porest is a list of PTrees.
Exactly one of those PTrees should have focus.
This function would move the focus of the Porest to align with the first PTree that has focus.
* DONE explaining some design decisions
** why the focus within the Results window is coded by hand
(where "by hand" = instead of using Brick's built-in focus concept).
*** in brief
Brick's "focus" selects among named Widgets.
Few things can be named: lists, editors, viewports and `cached`s.
In particular, a strWrap cannot be.

I could wrap the strWrap in a List, but that feels awkward.
*** things that can be named
cached
**** these won't work for holding a single widget
editor
viewport -- would be infinite-sized, because nested
* DONE ? obvious|stale|excessive
** why evaluating a Hash expression as a search is implemented
*** It sucks to have to:
create a node "projects like hode",
and then redundantly populate every such project x with
"x #is-like hode" and "x #is-in projects like hode",
*** I would prefer to
simply encode "x #is-like hode"
and create the weird search-node N = "/e /it #is-like hode".
  (Note that if I change hode's name, the search-node will still work).
Then, given a project (such as "#for hode #ask who cares"),
I would only have to create a relationship like "#re P #see N".
** forall and exists clauses for variable functions of variables
*** Example
 [ (X, ..)
   (Y,              Exists [X] $ ...)
   (W, Exists [Y] $ ForAll [X(Y)] ...)
   (V, Exists [Y] $ Exists [X(Y)] ...) ]
*** Analysis
 Y, W and V all quantify across some set of Xs.
 Y quantifies existentially across all the Xs.
   It draws those X values from the result of the X query.
 W and V quantify across only those Xs associated with the Y in question.
   They both draw X values the results of the Y query, not the X query.
** the "Hera's grandchild and not Zeus's child" query
*** query
 X <- every child of Zeus
 Y <- every child of Hera
 Z <- every child of some Y s.t. for all X, X /= Y
*** representation
 [ (X, QFind <child of Zeus> )
 , (Y, QFind <child of Hera> )
 , (Z, QForSome [Y] $ QAnd [ QFind <child of Y>
                           , QForAll [X] $ QTest <Y /= X> ] ) ]
*** algorithm
 For X: do it.
 For Y: do it.
 For Z: For each possible binding of Y
   for each C among the children of Y
     for each possible binding of X -- At this point the subst'n uses 2 vars.
       test whether X == Y
       if at any point they are equal, abort
     if that innermost loop never aborted
       add* the following association the Z-result:
         (Var "C" = C) -> (Var "Y" = Y)
         * where by "add" I mean use insertWith to add (Var "Y" = Y) to the
          set of possible bindings that make (Var "C" = C) valid..
** a variable (here, X) can be quantified existentially in one place and universally in another
*** query
 X <- in children(Zeus)
 Y <- in children(Hera)
 Z <- for some Y, in children(Y)
      & for all X, not equal to X
 W <- for some X, in children(X)
      & for all Z, for all Y(Z), not( has_battled( W, Y(Z) ) )
        Need two forall statements here because Y(Z) is meaningless until Z has a binding.
** disjunctions can make a variable's dependencies on other variables depend on the first one's value
*** The problem
 X <- children of Thor
 Y <- children of Malox
 Z <- for some Y, Z knows Y
      or for some X, Z knows X
 These are every person who knows a child of Thor or a child of Malox. For some values of Z, Y is defined and X not; for other values of Z, X is defined and Y not.
*** It can be solved by rewriting the query
 X <- children of Thor
 Y <- children of Malox
 W <- X or Y
 Z <- for some W, Z knows W
*** The first (problematic) query should be valid
*** But in that case certian result requests are meaningless
The user cannot ask for X(Z) or Y(Z).
*** Only common dependencies survive disjunction
When taking the disjunction of two queries, retain any variable dependencies that are defined for every member of the disjunction.
So, for instance, if one query is dependent on nothing, then no variable dependencies will be recorded.
*** A simple solution
In the course of binding variable X, only those bindings the binding depends on will be recorded.
This means, for instance, that there might be one value of X dependent on a binding for Y and not on Z, and another binding of X dependent on Z but not on Y.
When the user asks for a binding of X that depends on the binding of Y, any binding of X that does not depend on Y will be skipped.
** temporary user burdens: query order, dependency validity
Eventually the code should be able to determine which queries depend on which others, and whether a sequential solution exists.
* misfiled: lens tricks
** `partsOf` is cool
https://www.reddit.com/r/haskellquestions/comments/bz5dmp/how_to_implement_b_a_a_a_b_b/
